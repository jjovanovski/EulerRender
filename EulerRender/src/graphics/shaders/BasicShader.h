#pragma once

const char* BASIC_SHADER_VERTEX = "#version 330 core\n"
""
"layout (location = 0) in vec3 in_pos;"
"layout (location = 1) in vec3 in_normal;"
"layout (location = 2) in vec2 in_uv;"
"layout (location = 3) in vec3 in_tangent;"
""
"uniform mat4 proj, view, model;"
""
"out vec3 fragmentPos;"
"out vec3 fragmentNormal;"
"out vec3 fragmentTangent;"
"out vec3 fragmentBitangent;"
"out vec2 uvPos;"
""
"void main() {"
"	vec4 positionInWorld = model * vec4(in_pos, 1.0);"
"	gl_Position = proj * view * positionInWorld;"
"	"
"	fragmentNormal = normalize(mat3(transpose(inverse(model))) * in_normal);"
"	fragmentTangent = normalize(in_tangent);"
"	fragmentTangent = normalize(fragmentTangent - (dot(fragmentTangent, fragmentNormal)/dot(fragmentNormal, fragmentNormal))*fragmentNormal);"
"	fragmentBitangent = normalize(cross(fragmentTangent, fragmentNormal));"
"	"
"	fragmentPos = vec3(positionInWorld);"
"	uvPos = in_uv;"
"}";


const char* BASIC_SHADER_FRAGMENT = "#version 330 core\n"
""
"in vec3 fragmentPos;"
"in vec3 fragmentNormal;"
"in vec2 uvPos;"
"in vec3 fragmentTangent, fragmentBitangent;"
""
"struct Material {"
"	vec3 diffuse;"
"	vec3 specular;"
"	float shininess;"
"};"
"uniform Material material;"
""
"struct DirectionalLight {"
"	vec3 direction;"
"	vec3 color;"
"	float intensity;"
"};"
"uniform DirectionalLight directionalLight;"
""
"uniform vec3 lightPos;"
"uniform vec3 lightColor;"
"uniform float lightIntensity;"
""
"uniform vec3 cameraPos;"
""
"uniform sampler2D diffuseTex;"
"uniform sampler2D normalTex;"
"uniform float useTexture;"
"uniform float useNormalMap;"
""
"out vec4 fragColor;"
""
"vec3 calculateDirectionalLight(DirectionalLight dirLight, vec3 normal, vec3 viewDir);"
""
"void main() {"
"	vec3 fragmentNormalUnit = normalize(fragmentNormal);"
"	vec3 cameraDirection = normalize(cameraPos - fragmentPos);"
"	"
"	vec4 textureColor = vec4(1.0);"
"	if(useTexture > 0) textureColor = texture(diffuseTex, uvPos);"
"	"
"	if(useNormalMap > 0) {"
"		fragmentNormalUnit = normalize(vec3(texture(normalTex, uvPos)) * 2.5 - 1.0);"
"	}"
"	"
"	vec3 totalLight = calculateDirectionalLight(directionalLight, fragmentNormalUnit, cameraDirection);"
"	"
"	fragColor = vec4(totalLight, 1.0) * textureColor;"
"}"
""
"vec3 calculateDirectionalLight(DirectionalLight light, vec3 normal, vec3 viewDir) {"
"	vec3 ambient = light.color * (material.diffuse * 0.2);"
"	"
"	float diffuseIntensity = max(dot(-light.direction, normal), 0);"
"	vec3 diffuse = (light.color * diffuseIntensity * light.intensity) * material.diffuse;"
"	"
"	vec3 reflectDirection = normalize(reflect(-light.direction, normal));"
"	float specularIntensity = pow(max(dot(reflectDirection, viewDir), 0.0), material.shininess);"
"	vec3 specular = (light.color * specularIntensity * light.intensity) * material.specular;"
"	"
"	return ambient + diffuse + specular;"
"}"
"";
